# üñ•Ô∏è Simulador de Sistemas Operativos

Simulador visual desarrollado en **C++ con Qt 5** para representar algoritmos de planificaci√≥n de procesos mediante una interfaz gr√°fica interactiva con animaciones y diagrama de Gantt. Proyecto realizado como parte del curso de **Sistemas Operativos** en la **Universidad del Valle de Guatemala**.

---

## üì¶ Requisitos

- CMake >= 3.10  
- g++ con soporte para C++17  
- Qt5 (Qt5Widgets)

### ‚úÖ Instalar Qt5 (en Ubuntu / WSL):

```bash
sudo apt update
sudo apt install qtbase5-dev
````

Si su distribuci√≥n usa otro gestor de paquetes, aseg√∫rense de instalar `qtbase5-dev` (o equivalente) para que est√© disponible `Qt5Widgets`.

---

## ‚öôÔ∏è Compilaci√≥n (Opci√≥n 1)

1. Clone o descargue este repositorio:

   ```bash
   git clone https://github.com/PedroPabloGuzmanMayen/Proyecto2_OS.git
   cd Proyecto2_OS
   ```
2. Cree y entre a la carpeta de compilaci√≥n:

   ```bash
   mkdir build
   cd build
   ```
3. Configure el proyecto con CMake y comp√≠lalo:

   ```bash
   cmake ..
   make
   ```

   Esto generar√° los ejecutables `simulador` y `tests` dentro de `build/`.

### üîÅ Opci√≥n 2: **Recrear la carpeta `build/` desde cero**

(Si se cambian rutas, archivos `.h` con `Q_OBJECT`, o se tienen errores raros), haga lo siguiente:

```bash
cd Proyecto2_OS
rm -rf build
mkdir build
cd build
cmake ..
make
```

---

## ‚ñ∂Ô∏è Ejecuci√≥n del simulador

Desde la carpeta `build/`, ejecute:

```bash
./simulador
```

Se abrir√° una ventana con un men√∫ principal con dos opciones:

* **Opci√≥n 1 del men√∫ principal - Simulador visual**

Se abrir√° una ventana con:

* **Simulaci√≥n A (Calendarizaci√≥n de procesos):**

  * Selector de algoritmo (FIFO, SJF, SRT, Round Robin, Priority).
  * Campo ‚ÄúQuantum‚Äù (visible solo si elige Round Robin).
  * Botones para ‚ÄúSimulaci√≥n A‚Äù y ‚ÄúAbrir resultados Sim A‚Äù.
    
* **Simulaci√≥n B (Mutex‚Äâ/‚ÄâSem√°foros):**

  * Rutas para tres archivos de entrada:

    1. `procesos.txt` (lista de procesos con PID, duraci√≥n, llegada, prioridad)
    2. `recursos.txt` (lista de recursos con nombre y contador)
    3. `acciones.txt` (acciones de cada proceso sobre los recursos)
  * Opci√≥n de ‚ÄúMutex Locks‚Äù o ‚ÄúSem√°foro‚Äù.
  * Botones ‚ÄúVer Procesos‚Äù, ‚ÄúVer Recursos‚Äù, ‚ÄúVer Acciones‚Äù, ‚ÄúLimpiar Sim B‚Äù y ‚ÄúSimulaci√≥n B‚Äù.

* **Opci√≥n 2 del men√∫ principal - Calcular estad√≠sticas de m√∫ltiples algoritmos**

  * Selector m√∫ltiple de algoritmos (FIFO, SJF, SRT, Round Robin, Priority).
  * Bot√≥n calcular estad√≠sticas (muestra las estad√≠sticas de cada uno de los algortimos seleccionados previamente y muestra el mejor algoritmo con el mejor tiempo promedio).

---

## ‚ñ∂Ô∏è Ejecuci√≥n de Tests

Desde la carpeta `build/`, ejecute:

```bash
./tests
```

**Descripci√≥n de `tests.cpp`:**
El archivo `tests.cpp` verifica el correcto funcionamiento de todos los algoritmos y mecanismos implementados en el simulador. Cada test hace lo siguiente:

1. **FIFO simple:**

    * Crea tres procesos con diferentes tiempos de llegada y r√°faga.
    * Invoca `fifo(procesos, nullptr)` y comprueba que el orden de salida sea `P1, P2, P3` (primer llegado, primer servido).
      
 2. **SJF simple:**

    * Crea tres procesos cuyos tiempos de r√°faga son 5, 3 y 4.
    * Invoca `shortestJobFirst(procesos, nullptr)` y comprueba que la secuencia de PIDs siga el orden de r√°faga ascendente: `P2 (3)`, `P3 (4)`, `P1 (5)`.
      
 3. **Priority simple:**

    * Crea tres procesos con prioridades 2, 1 y 3.
    * Invoca `priorityScheduling(procesos, nullptr)` y comprueba que la secuencia de PIDs siga el orden de prioridad ascendente: `P2 (1)`, `P1 (2)`, `P3 (3)`.
      
 4. **Round Robin simple:**

    * Crea tres procesos con r√°fagas 5, 3 y 4 y asigna un quantum de 2.
    * Invoca `roundRobin(procesos, quantum, dummy, nullptr)`.
    * Filtra la primera aparici√≥n de cada PID en la lista completa de ejecuciones y comprueba que el orden de inicio sea `P1, P2, P3`.
      
 5. **SRT simple:**

    * Crea tres procesos con r√°fagas 5, 3 y 4.
    * Invoca `shortestRemainingTime(procesos, bloques, nullptr)` y comprueba que la secuencia final de procesos sea `P2, P1, P3` (el proceso de r√°faga m√°s corta se ejecuta primero, con preempci√≥n).
      
 6. **Mutex simple:**

    * Crea dos procesos que compiten por un recurso con capacidad 1.
    * Define dos acciones de tipo READ en el mismo ciclo para `P1` y `P2`.
    * Invoca `simulateMutex(acciones, recursos, procesos, nullptr, nullptr)` y comprueba que la l√≠nea de tiempo resulte en tres bloques:

      1. `P1 ACCESS`
      2. `P2 WAIT`
      3. `P2 ACCESS`
         
 7. **Sem√°foro simple:**

    * Crea dos procesos que compiten por un recurso con capacidad 2.
    * Define dos acciones de tipo READ en el mismo ciclo para `P1` y `P2`.
    * Invoca `simulateSyncSemaforo(acciones, recursos, procesos, nullptr, nullptr)` y comprueba que ambos accedan sin esperas, resultando en dos bloques `ACCESS`.

 Al finalizar, muestra un resumen con la cantidad de tests pasados y fallidos.

---

## üìÇ Archivos de entrada

### Simulaci√≥n A: `data/procesos.txt`

Ubicado en `data/`, este archivo contiene la lista de procesos con el formato CSV:

```
<PID>,<DURACI√ìN>,<LLEGADA>,<PRIORIDAD>
```

**Ejemplo:**

```txt
P1,5,0,2
P2,3,1,1
P3,8,2,3
P4,6,3,2
```

* **PID**: identificador √∫nico (no puede repetirse ni estar vac√≠o).
* **DURACI√ìN**: burstTime > 0 (entero).
* **LLEGADA**: arrivalTime ‚â• 0 (entero).
* **PRIORIDAD**: ‚â• 0 (entero).

Si el archivo contiene l√≠neas mal formateadas, valores no num√©ricos o valores fuera de rango (burstTime ‚â§ 0, arrivalTime < 0, prioridad < 0) o PIDs duplicados, al hacer clic en **Simulaci√≥n A** se mostrar√° un √∫nico cuadro emergente (`QMessageBox::warning`) con todos los errores detectados (por ejemplo:

```
BurstTime inv√°lido en l√≠nea 2 : "-3"
ArrivalTime inv√°lido en l√≠nea 3 : "mal"
Formato incorrecto en l√≠nea 4 : "P4,6,3"
Proceso duplicado detectado: PID "P1" en l√≠nea 5
Priority inv√°lido en l√≠nea 6 : "‚Äì1"
```

) y la simulaci√≥n no avanzar√° hasta que el archivo sea corregido.

---

### Simulaci√≥n B:

Hay tres archivos de entrada, todos ubicados en `data/` por defecto:

1. **`procesos.txt`**
   Mismo formato que en la Simulaci√≥n A:

   ```txt
   <PID>,<DURACI√ìN>,<LLEGADA>,<PRIORIDAD>
   ```

   Validaciones:

   * PID no vac√≠o ni repetido.
   * burstTime > 0, arrivalTime ‚â• 0, prioridad ‚â• 0.
   * Si hay errores, al hacer ‚ÄúSimulaci√≥n B‚Äù se mostrar√° un √∫nico `QMessageBox::warning` con todos los mensajes y no avanzar√°.

2. **`recursos.txt`**
   Cada l√≠nea:

   ```txt
   <NOMBRE>,<COUNT>
   ```

   * **NOMBRE**: cadena no vac√≠a, no repetida.
   * **COUNT**: entero v√°lido ‚â• 0 (si < 0 o no num√©rico, produce error).
     Ejemplo:

   ```txt
   R1,1
   R2,2
   R3,1
   ```

   * Si hay errores (formato incorrecto, nombre vac√≠o, cantidad negativa, duplicados), aparece un `QMessageBox::warning` con todos los errores y la simulaci√≥n se detiene.

3. **`acciones.txt`**
   Cada l√≠nea:

   ```txt
   <PID>,<ACTION>,<RECURSO>,<CICLO>
   ```

   * **PID**: debe existir en el `procesos.txt` cargado.
   * **ACTION**: ‚ÄúREAD‚Äù o ‚ÄúWRITE‚Äù (coma sensible a may√∫sculas).
   * **RECURSO**: nombre de recurso no vac√≠o (debe existir en `recursos.txt`).
   * **CICLO**: entero ‚â• 0.
   * No pueden repetirse tres acciones con el mismo pid, action, recurso y ciclo (clave √∫nica).
   * Si hay errores de formato o valores inv√°lidos o duplicados, se muestra un `QMessageBox::warning` con todos los errores y se detiene la simulaci√≥n.

Adem√°s, tras cargar correctamente estos tres archivos, la funci√≥n interna `validateAndSortActions` verifica que para cada acci√≥n `cycle ‚â• arrivalTime(proceso)`. Si alguna acci√≥n viola esto o referencia un PID    que no existe, se lanza un `QMessageBox::critical` con la lista de errores de validaci√≥n y no avanza.

---

## üìà Visualizaci√≥n y flujo

### 1. Simulaci√≥n A (algoritmos de planificaci√≥n)

1. Seleccion√© o ingres√© la ruta de tu `procesos.txt`.
2. Elija un algoritmo (FIFO, SJF, SRT, Round Robin, Priority).

   * Si se elije **Round Robin**, aparecer√° autom√°ticamente el campo **Quantum**. Debe ser entero > 0.
   * Si `quantum ‚â§ 0`, aparece un `QMessageBox::warning` (‚ÄúQuantum inv√°lido‚Ä¶‚Äù) y la simulaci√≥n no arranca.
     
3. Haga clic en **Simulaci√≥n A**.

   * Si el archivo tiene errores, ver√°s un `QMessageBox` con la lista y no se dibuja nada.
   * Si todo es v√°lido, se abrir√° un panel **GanttWindow** donde, paso a paso (con delay de \~300 ms por ciclo), se ir√° dibujando cada bloque de CPU para cada proceso.
   * Al finalizar, se genera `build/resultados_simA.txt` con formato CSV:

     ```
     PID,StartTime,CompletionTime,WaitingTime,TurnaroundTime
     P1,0,5,0,5
     P2,5,8,4,7
     ...
     ```
   * Adem√°s, aparece un cuadro emergente (`QMessageBox`) que muestra el orden de ejecuci√≥n y el tiempo de espera promedio.
   * Puede pulsar **‚ÄúAbrir resultados Simulaci√≥n A‚Äù** para ver ese archivo en un di√°logo de texto.

### 2. Simulaci√≥n B (mutex / sem√°foros)

1. Selecciona o usa por defecto los tres archivos (`procesos.txt`, `recursos.txt`, `acciones.txt`).
2. Elige **Mutex Locks** o **Sem√°foro**.
3. Haga clic en **Simulaci√≥n B**.

   * Si alguno de los tres archivos tiene errores (mal formato, valores inv√°lidos, duplicados, acci√≥n con ciclo < arrivalTime, recurso desconocido, PID no encontrado), ver√°s un **√∫nico** `QMessageBox::warning` (o `QMessageBox::critical` si la violaci√≥n ocurre en validaci√≥n de acciones).
   * La simulaci√≥n se detiene y no se dibuja nada.
     
4. Si todo es v√°lido, aparecer√° un `GanttWindow` y, para cada acci√≥n, se ejecutar√°:

   1. Se libera cualquier acceso terminado antes del ciclo actual.
   2. Si el recurso est√° ocupado (used ‚â• capacity), se genera un bloque de **WAIT** (duraci√≥n = nextFree ‚Äì requestedCycle), que se dibuja paso a paso en rojo.
   3. Luego se genera un bloque de **ACCESS** (duraci√≥n = 1) en verde, que tambi√©n se dibuja.
   4. Se registra en `endTimes` cu√°ndo se libera (start + 1).
      
5. Al terminar, se muestra un cuadro con formato HTML que lista cada bloque en orden:

   ```
   P1 | R1 | Ciclo: 0 | <span style='color:green; font-weight:bold;'>ACCESS</span><br>
   P2 | R2 | Ciclo: 1 | <span style='color:red; font-weight:bold;'>WAIT</span><br>
   ...
   ```

---

## ‚úçÔ∏è A√±adidos de ‚ÄúProgramaci√≥n Defensiva‚Äù

1. **Detecci√≥n de errores en archivos** (`.txt` de procesos, recursos, acciones):

   * Se valida formato de cada l√≠nea, conversiones num√©ricas, valores fuera de rango, duplicados.
   * Si se detecta **al menos un** error, se construye un `QStringList` con mensajes detallados (por l√≠nea):

     * Ejemplos en `proceso.cpp`:

       ```
       BurstTime inv√°lido en l√≠nea 2 : "-3"
       ArrivalTime inv√°lido en l√≠nea 3 : "mal"
       Proceso duplicado detectado: PID "P1" en l√≠nea 5
       ```
     * Ejemplos en `synchronizer.cpp` (recursos.txt):

       ```
       Cantidad negativa para recurso "R2" en l√≠nea 2
       Recurso duplicado detectado: "R2" en l√≠nea 3
       ```
     * Ejemplos en `synchronizer.cpp` (acciones.txt):

       ```
       Tipo de acci√≥n no reconocido en l√≠nea 4 : "EDIT"
       Acci√≥n duplicada detectada en l√≠nea 5 : PID="P1" ACTION="READ" RECURSO="R1" CICLO=0
       Proceso P2 no encontrado para acci√≥n en ciclo 1
       ```
   * Al final de la carga de cada archivo, si hay errores, se muestra un **solo** `QMessageBox::warning` (o `critical` en validaci√≥n de acciones) con la lista completa. La simulaci√≥n **no contin√∫a** hasta corregirlos.

2. **Validaci√≥n de `cycle ‚â• arrivalTime` en Sim B**:

   * Si una acci√≥n se programa antes de que el proceso exista, `validateAndSortActions(...)` agrega un mensaje al acumulador y, al detectar cualquiera, muestra un `QMessageBox::critical` con todos los errores y retorna `false`, abortando la simulaci√≥n.

3. **Chequeos en Sim A**:

   * Se verifica que el vector de procesos no est√© vac√≠o y que cada campo (burstTime, arrivalTime, priority) sea v√°lido.
   * Si elige Round Robin, se comprueba `quantum > 0`. En caso contrario, se muestra un `QMessageBox::warning` y se detiene.

---

## üìÅ Estructura del proyecto

```
Proyecto2_OS/
‚îú‚îÄ‚îÄ gui/                  # C√≥digos de la interfaz gr√°fica con Qt
‚îÇ   ‚îú‚îÄ‚îÄ gui.cpp           # Implementaci√≥n de la ventana principal y slots
‚îÇ   ‚îú‚îÄ‚îÄ gui.h             # Declaraci√≥n de SimuladorGUI
‚îÇ   ‚îú‚îÄ‚îÄ mainmenu.cpp      # Subventana de men√∫ inicial (si aplica)
‚îÇ   ‚îú‚îÄ‚îÄ mainmenu.h        # Ventana del men√∫ principal del programa
‚îÇ   ‚îú‚îÄ‚îÄ estadisticas.cpp  # Ventana de estad√≠sticas
‚îÇ   ‚îî‚îÄ‚îÄ estadisticas.h    # Headers de estad√≠sticas
‚îú‚îÄ‚îÄ include/              # Headers p√∫blicos
‚îÇ   ‚îú‚îÄ‚îÄ algoritmo.h       # Declaraci√≥n de algoritmos de planificaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ proceso.h         # Estructura Proceso
‚îÇ   ‚îú‚îÄ‚îÄ ganttwindow.h     # Declaraci√≥n de GanttWindow (Qt Widget)
‚îÇ   ‚îú‚îÄ‚îÄ priorityQueue.h   # Estructura de cola m√≠nima usada en SRT
‚îÇ   ‚îú‚îÄ‚îÄ sincronizer.h     # Declaraci√≥n de funciones de Simulaci√≥n B
‚îÇ   ‚îú‚îÄ‚îÄ tipOS.h           # Tipos compartidos (BloqueGantt, BloqueSync, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ tipos.h           # (Alias de BloqueSync, si aplica)
‚îú‚îÄ‚îÄ src/                  # L√≥gica de simulaci√≥n y ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ main.cpp          # `main()` que muestra SimuladorGUI
‚îÇ   ‚îú‚îÄ‚îÄ algoritmo.cpp     # Implementaci√≥n de algoritmos (FIFO, SJF, RR, SRT, Priority) con defensivas
‚îÇ   ‚îú‚îÄ‚îÄ proceso.cpp       # Funci√≥n cargarProcesosDesdeArchivo(...) con validaciones y pop-ups
‚îÇ   ‚îú‚îÄ‚îÄ ganttwindow.cpp   # Implementaci√≥n de la ventana de Gantt (dibujar bloques)
‚îÇ   ‚îú‚îÄ‚îÄ synchronizer.cpp  # Implementaci√≥n de loadRecursos, loadAcciones y simulateSync con defensivas
‚îÇ   ‚îú‚îÄ‚îÄ priorityQueue.cpp # Implementaci√≥n de cola m√≠nima usada en SRT
‚îÇ   ‚îî‚îÄ‚îÄ proceso.cpp       # (Repetido) Manejador de lectura de procesos
‚îú‚îÄ‚îÄ test/                 # Pruebas unitarias de los algoritmos de planificaci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ tests.cpp         # Casos de prueba para FIFO, SJF, SRT, RR, Priority (Simulaci√≥n A) y casos de prueba para Mutex Lock y sem√°foros (Simulaci√≥n B)
‚îú‚îÄ‚îÄ data/                 # Archivos de entrada por defecto
‚îÇ   ‚îú‚îÄ‚îÄ procesos.txt      # Lista de procesos (sim A y B)
‚îÇ   ‚îú‚îÄ‚îÄ recursos.txt      # Lista de recursos (sim B)
‚îÇ   ‚îî‚îÄ‚îÄ acciones.txt      # Acciones sobre recursos (sim B)
‚îú‚îÄ‚îÄ build/                # Carpeta generada por CMake (ignorado en Git)
‚îú‚îÄ‚îÄ CMakeLists.txt        # Archivo principal de CMake
‚îî‚îÄ‚îÄ README.md             # Este archivo
```

---

## üìö Autores

* **Pablo Daniel Barillas**
  
* **Pedro Pablo Guzm√°n**
  
* **Esteban Zambrano**

Proyecto universitario ‚Äì Universidad del Valle de Guatemala

Curso: **Sistemas Operativos**, secci√≥n: **40**

Docente: **Sebasti√°n Galindo**

A√±o: **2025**
